<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Previs√£o Clim√°tica - AgroSapiens</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --verde-primario: #2E7D32;
            --verde-secundario: #81C784;
            --verde-claro: #E8F5E9;
        }
        
        body {
            background-color: var(--verde-claro);
            padding: 2rem;
        }

        .day-card {
    background: linear-gradient(145deg, #2E7D32, #1B5E20);
    border-radius: 25px;
    padding: 1.5rem;
    margin: 0; /* Alterado */
    box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    transform: translateY(20px);
    opacity: 0;
    transition: all 0.3s ease;
    color: white;
    min-height: 280px;
    border: none;
}

        .day-card h3 {
    color: #ffffff !important;
    font-size: 1.4rem;
    margin-bottom: 0.5rem;
}
        
.day-card .date-text {
    color: #e0e0e0 !important;
    font-size: 0.9rem;
    opacity: 0.9;
    margin-bottom: 1rem;
}
        
        .day-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 32px rgba(0,0,0,0.15);
        }
        
        .weather-emoji {
            font-size: 3.5rem;
            margin-bottom: 1.5rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .chart-container {
    background: white;
    border-radius: 15px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    min-height: 400px;
}
        
        /* Novos estilos adicionados */
        .forecast-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    padding: 1rem;
}

        
.weather-tip {
    background: rgba(255, 255, 255, 0.15) !important;
    color: #ffffff !important;
    border-radius: 12px;
    padding: 1rem !important;
    font-size: 0.95rem;
    line-height: 1.5;
}
        
.temperature-range {
    color: #ffffff !important;
    font-size: 2rem !important;
    text-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

        .day-card:active {
    transform: scale(0.97) !important;
    transition: transform 0.1s ease-in-out !important;
}
.weather-description {
    color: #ffffff !important;
    font-size: 1.1rem;
    margin-bottom: 1.5rem;
    min-height: 3rem;
    font-weight: 500;
}
.fade-out {
    opacity: 0;
    transition: opacity 0.5s ease-out;
}
/* Piscar suave */
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.clicked-pulse {
    animation: pulse 0.3s ease-in-out;
}
    </style>
</head>
<body>
    <div class="container">
        <a href="/index" class="btn btn-agro mb-3">üè† Voltar ao Painel Principal</a>
        <a href="/radio" class="btn btn-agro mb-3">üìª Ir para o R√°dio</a>
        
        <h1 class="display-4 mb-4">üå¶Ô∏è Previs√£o 5 Dias</h1>
        
        <div class="chart-container" style="position: relative;">
            <canvas id="weatherChart"></canvas>
        </div>

        <div class="forecast-grid" id="forecastDays"></div>

    </div>

    <script>
        async function getCityCoordinates() {
        try {
            const response = await fetch('/get_user_city');
            const city = await response.json();
            
            // Primeiro busca as coordenadas da cidade
            const geoResponse = await fetch(
                `https://api.openweathermap.org/geo/1.0/direct?q=${city}&limit=1&appid=${API_KEY}`
            );
            const geoData = await geoResponse.json();
            
            if (geoData.length === 0) throw new Error('Cidade n√£o encontrada');
            
            return {
                lat: geoData[0].lat,
                lon: geoData[0].lon
            };
        } catch (error) {
            console.error('Erro ao obter coordenadas:', error);
            return { lat: -9.6481, lon: -37.7928 }; // Fallback para Canind√© de S√£o Francisco
        }
    }

    const API_KEY = '4f767637cb5cac126e3ae075b0051f2a'; // Mantenha sua chave aqui

    async function fetchWeather() {
    try {
        // Passo 1: Obter coordenadas
        const coordsResponse = await fetch('/weather/coordinates');
        
        if (!coordsResponse.ok) {
            const error = await coordsResponse.json();
            throw new Error(error.error || 'Erro na conex√£o com o servidor');
        }
        
        const coordsData = await coordsResponse.json();
        
        // Passo 2: Montar URL corretamente conforme documenta√ß√£o
        const forecastUrl = new URL('api.openweathermap.org/data/2.5/forecast?');
        forecastUrl.searchParams.append('lat=', coordsData.lat);
        forecastUrl.searchParams.append('&lon', coordsData.lon);
        forecastUrl.searchParams.append('&appid=', API_KEY);
        forecastUrl.searchParams.append('&units=', 'metric');
        forecastUrl.searchParams.append('&lang=', 'pt_br');
        
        // Passo 3: Fazer chamada √† API
        const forecastResponse = await fetch(forecastUrl);
        
        if (!forecastResponse.ok) {
            const errorData = await forecastResponse.json();
            throw new Error(errorData.message || 'Erro na previs√£o do tempo');
        }
        
        // Processar dados
        const forecastData = await forecastResponse.json();
        const processedData = processForecastData(forecastData.list);
        
        renderForecast(processedData);
        renderChart(processedData);
        
    } catch (error) {
        console.error("Erro na obten√ß√£o de dados:", error);
        handleWeatherError(error);
    }
}

function handleWeatherError(error) {
    // Fallback para coordenadas padr√£o
    const fallbackCoords = { lat: -9.66, lon: -37.7894 }; // Canind√© de S√£o Francisco
    
    fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${fallbackCoords.lat}&lon=${fallbackCoords.lon}&appid=${API_KEY}&units=metric&lang=pt_br`)
        .then(response => {
            if (response.ok) return response.json();
            throw new Error('Fallback falhou');
        })
        .then(data => {
            const processedData = processForecastData(data.list);
            renderForecast(processedData);
            renderChart(processedData);
            showPopup(`‚ö†Ô∏è Dados de ${current_user.city} indispon√≠veis. Exibindo dados de S√£o Paulo`);
        })
        .catch(() => {
            // Fallback para dados simulados
            const processedData = getFallbackData();
            renderForecast(processedData);
            renderChart(processedData);
            showPopup('‚ö†Ô∏è Sistema offline. Dados simulados em uso');
        });
}

function processForecastData(forecastList) {
    const dailyData = {};
    
    forecastList.forEach(item => {
        const date = new Date(item.dt * 1000);
        const dayKey = date.toLocaleDateString('pt-BR', {
            timeZone: 'America/Sao_Paulo',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric'
        });
        
        if (!dailyData[dayKey]) {
            dailyData[dayKey] = {
                temps: [],
                humidity: [],
                weather: [],
                pop: [],
                rain: [],
                date: date
            };
        }
        
        // Coletar dados completos
        dailyData[dayKey].temps.push(item.main.temp);
        dailyData[dayKey].humidity.push(item.main.humidity);
        dailyData[dayKey].weather.push(item.weather[0].description.toLowerCase());
        dailyData[dayKey].pop.push(item.pop * 100);
        dailyData[dayKey].rain.push(item.rain ? item.rain['3h'] || 0 : 0);
    });

    return Object.keys(dailyData).slice(0, 5).map((key, index) => {
        const day = dailyData[key];
        return {
            dayNumber: index + 1,
            date: day.date,
            maxTemp: Math.round(Math.max(...day.temps)),
            minTemp: Math.round(Math.min(...day.temps)),
            humidity: Math.round(day.humidity.reduce((a, b) => a + b, 0) / day.humidity.length),
            weather: capitalizeFirstLetter(mostFrequent(day.weather)),
            pop: Math.round(day.pop.reduce((a, b) => a + b, 0) / day.pop.length),
            totalRain: Math.round(day.rain.reduce((a, b) => a + b, 0))
        };
    });
}

function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function mostFrequent(arr) {
    const frequencyMap = arr.reduce((acc, cur) => {
        acc[cur] = (acc[cur] || 0) + 1;
        return acc;
    }, {});
    
    return Object.entries(frequencyMap).sort((a, b) => b[1] - a[1])[0][0];
}

function debugData() {
    console.log("Dados brutos da API:", forecastData);
    console.log("Dados processados:", processedData);
}

        function groupByDay(forecastList) {
            const days = {};
            forecastList.forEach(item => {
                const date = new Date(item.dt * 1000);
                const dayKey = date.toISOString().split('T')[0]; // Formato YYYY-MM-DD
                
                if (!days[dayKey]) {
                    days[dayKey] = {
                        temps: [],
                        humidity: [],
                        weather: [],
                        date: date
                    };
                }
                
                days[dayKey].temps.push(item.main.temp);
                days[dayKey].humidity.push(item.main.humidity);
                days[dayKey].weather.push(item.weather[0].description);
            });

            // Processa para obter max/min e dados m√©dios
            return Object.keys(days).map(key => {
                const day = days[key];
                return {
                    date: day.date,
                    maxTemp: Math.round(Math.max(...day.temps)),
                    minTemp: Math.round(Math.min(...day.temps)),
                    humidity: Math.round(day.humidity.reduce((a, b) => a + b, 0) / day.humidity.length),
                    weather: day.weather[0] // Pega a primeira descri√ß√£o do dia
                };
            }).slice(0, 5); // Limita a 5 dias
        }
        
        function getWeatherEmoji(description) {
    const emojiMap = {
        'c√©u limpo': '‚òÄÔ∏è',
        'aberturas de sol': 'üå§Ô∏è',
        'pouco de sol': '‚õÖ',
        'retorna o sol': '‚õÖ',
        'nublado': '‚òÅÔ∏è',
        'chuviscos': 'üå¶Ô∏è',
        'pancadas': 'üåßÔ∏è',
        'chuva forte': '‚õàÔ∏è',
        'tempestade' : '‚õàÔ∏è',
        'tempestade com trovoadas': 'üå©Ô∏è',
        'neve': '‚ùÑÔ∏è',
        'n√©voa': 'üå´Ô∏è',
        'n√©voa √∫mida': 'üåÅ',
        'tornado': 'üå™Ô∏è',
        'p√≥ em suspens√£o': 'üí®',
        'fuma√ßa': 'üí®',
        'n√©voa seca': 'üå´Ô∏è'
    };

    // Normaliza√ß√£o mais agressiva
    const normalizedDesc = description
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z ]/g, "");

    for (const [key, emoji] of Object.entries(emojiMap)) {
        const normalizedKey = key
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-z ]/g, "");
        
        if (normalizedDesc.includes(normalizedKey)) {
            return emoji;
        }
    }
    
    return 'üå°Ô∏è'; // Emoji padr√£o
}

function renderForecastFromFlask() {
    const forecastContainer = document.getElementById('forecastDays');
    forecastContainer.innerHTML = '';

    fetch('/status')
    .then(response => response.json())
    .then(data => {
        const forecastList = data.forecast; // aqui vem a lista do Flask
        console.log("Forecast recebido:", forecastList); // debug üëÄ

        forecastList.forEach(day => {
            const formattedDate = new Date(day.date).toLocaleDateString('pt-BR', {
                day: 'numeric',
                month: 'short',
                weekday: 'short'
            });

            const dayCard = `
            <div class="day-card">
                <div class="weather-emoji">${getWeatherEmoji(day.weather)}</div>
                <h3 class="fw-bold">Dia: ${day.dayNumber}</h3>
                <p class="date-text mb-2">Data: ${day.dateDay}</p>
                <p class="temperature-range">${day.maxTemp}C${day.minTemp}C</p>
                <p class="weather-description">${day.weather}</p>
                <div class="weather-tip">
                    üå¨Ô∏è Vento: ${day.wind}<br>
                    üåßÔ∏è Chance de Chover: ${day.totalRain}<br>
                    ${getWeatherTip(day)}
                </div>
            </div>`;
            
            forecastContainer.innerHTML += dayCard;
        });

        // Anima√ß√£o
        document.querySelectorAll('.day-card').forEach((card, index) => {
            setTimeout(() => {
                card.style.opacity = '1';
                card.style.transform = 'translateY(0)';
            }, index * 150);
        });
        renderChart(forecastList);
    })
    .catch(error => console.error("Erro ao buscar forecast do Flask:", error));
}

// chama logo ao carregar a p√°gina
document.addEventListener("DOMContentLoaded", renderForecastFromFlask);

function getWeatherTip(day) {
    day.totalRain = parseInt(day.totalRain); // converte string para inteiro
    day.maxTemp = parseInt(day.maxTemp);
    day.minTemp = parseInt(day.minTemp);

    if (day.totalRain > 60) {
    return '‚ö†Ô∏è √â muito poss√≠vel que chova hoje!';
  } else if (day.totalRain > 40) { 
    return '‚ö†Ô∏è Pode ser que chova ou garoe hoje.';
  } else if (day.totalRain > 20) {
    return '‚ö†Ô∏è N√£o vai chover, pode ser que garoe hoje.';
  } else { // day.totalRain <= 0
    return '‚ö†Ô∏è N√£o ir√° chover nem garoar hoje!';
  }
    if (day.maxTemp > 29) {
        return 'üå°Ô∏è Temperatura alta! Cuidado';
    } else if (day.maxTemp >= 21) {
        return 'üå± Condi√ß√µes ideais para cultivo';
    } else {
        return '‚ùÑÔ∏è Hoje ser√° um dia frio! Cuidado';
  }
        
}

function formatDateForChart(dateStr) {
    const date = new Date(dateStr);
    if (isNaN(date)) return ''; // evita Invalid Date
    return date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: 'short' });
}

function renderChart(forecastList) {
    if (window.weatherChart instanceof Chart) {
        window.weatherChart.destroy();
    }
    const ctx = document.getElementById('weatherChart').getContext('2d');

    // Labels e dados
    const labels = forecastList.map(day => formatDateForChart(day.date));
    const maxTemps = forecastList.map(day => parseFloat(day.maxTemp));
    const minTemps = forecastList.map(day => parseFloat(day.minTemp));

    window.weatherChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'M√°xima (¬∞C)',
                    data: maxTemps,
                    borderColor: '#2E7D32',
                    backgroundColor: 'rgba(46, 125, 50, 0.1)',
                    tension: 0.3,
                    borderWidth: 2
                },
                {
                    label: 'M√≠nima (¬∞C)',
                    data: minTemps,
                    borderColor: '#81C784',
                    backgroundColor: 'rgba(129, 199, 132, 0.1)',
                    tension: 0.3,
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top' },
                title: { display: true, text: 'Varia√ß√£o de Temperatura - Pr√≥ximos 5 Dias' }
            },
            scales: {
                y: { 
                    title: { display: true, text: 'Temperatura (¬∞C)' },
                    min: 0,      // fixa o m√≠nimo
                    max: 40      // fixa o m√°ximo
                },
                x: { 
                    grid: { display: false } 
                }
            }
        }
    });
}

        fetchWeather();
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            document.getElementById("forecastDays").addEventListener("click", function(event) {
    const card = event.target.closest(".day-card");
    if (!card) return;

    card.classList.add('clicked-pulse');
    setTimeout(() => card.classList.remove('clicked-pulse'), 300);
    // Efeito de pressionar
    card.style.transform = 'scale(0.98)';
    setTimeout(() => card.style.transform = 'scale(1)', 100);
        const date = card.querySelector("h3").textContent;
        const temperature = card.querySelector(".temperature-range").textContent;
        const weather = card.querySelector(".weather-description").textContent;
        const tip = card.querySelector(".weather-tip").textContent;
        

        const message = `A previs√£o para ${date} √© de ${weather}, com temperaturas entre ${temperature}. Teria como voc√™ explicar isso de forma simples didaticamente? Al√©m disso, me forne√ßa 3 dicas simples e pr√°ticas! Lembre-se de ser sempre curto e inicie sua mensagem com "Previs√£o do Tempo do dia x", sendo o dia X o dia que mandei. Utilize no m√°ximo 250 caracteres para isso tudo que pedi! Nunca chame os numeros "1" de dias pelo cardinais, e sim ordinais por extenso, ex: 'Primeiro'! Seja simples, mas seu portugues √© bom, nunca erra! Trate sempre o usu√°rio tamb√©m. Seja imperativo chamando o de agricultor ${tip}`;
        fetchSummaryAndGenerateTTS(message);
    });
});

function fetchSummaryAndGenerateTTS(message) {
    fetch("/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: message, history: [] })
    })
    .then(response => response.json())
    .then(data => {
        showPopup(`AgroSapiens: ${data.response}`);
        playTTS(data.audio);
    })
    .catch(error => console.error("Erro ao obter resposta do GPT:", error));
}

function playTTS(audioFilename) {
    if (audioFilename) {
        const audio = new Audio(`/tts/${audioFilename}`);
        audio.play().catch(error => console.error("Erro ao reproduzir √°udio:", error));
    }
}

function showPopup(message) {
    let popup = document.createElement("div");
    popup.innerText = message;
    popup.style.position = "fixed";
    popup.style.bottom = "20px";
    popup.style.left = "50%";
    popup.style.transform = "translateX(-50%)";
    popup.style.backgroundColor = "#2E7D32";
    popup.style.color = "white";
    popup.style.padding = "15px";
    popup.style.borderRadius = "10px";
    popup.style.boxShadow = "0px 4px 10px rgba(0, 0, 0, 0.2)";
    popup.style.fontSize = "1.2rem";
    popup.style.opacity = "0";
    popup.style.transition = "opacity 0.5s ease-in-out, transform 0.5s ease-in-out";

    document.body.appendChild(popup);
    setTimeout(() => {
        popup.style.opacity = "1";
        popup.style.transform = "translateX(-50%) translateY(-10px)";
    }, 100);
    
    setTimeout(() => {
        popup.style.opacity = "0";
        popup.style.transform = "translateX(-50%) translateY(10px)";
        setTimeout(() => popup.remove(), 500);
    }, 60000);
}

function animateCard(card) {
    card.style.transition = "transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out";
    card.style.transform = "scale(1.05)";
    card.style.boxShadow = "0px 10px 20px rgba(0, 0, 0, 0.3)";
}

function resetCardAnimation(card) {
    card.style.transform = "scale(1)";
    card.style.boxShadow = "0px 4px 10px rgba(0, 0, 0, 0.2)";
}
        </script>
    

    <script>
        // Sistema de navega√ß√£o com transi√ß√£o
        function navigateTo(event, url) {
            event.preventDefault();
            document.body.classList.add('fade-out');
            
            setTimeout(() => {
                window.location.href = url;
            }, 500);
        }
    
        // Intercepta todos os cliques em links
        document.querySelectorAll('a').forEach(link => {
            if(link.href && !link.hash) { // Ignora √¢ncoras
                link.addEventListener('click', (e) => navigateTo(e, link.href));
            }
        });
    </script>
</body>